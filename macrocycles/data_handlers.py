from abc import ABC, abstractmethod
from collections import namedtuple

import iterators
import project_io
import utils


class IDataHandler(ABC):
    """
    Interface for classes that couple together specific IO classes in order to supply and write data for a specific
    Generator class.
    """

    @abstractmethod
    def __init__(self, **kwargs):
        """
        Abstract initializer used to instantiate the IO classes for loading and saving the data required and generated
        by the derived DataHandler's coupled Generator class.
        """

    @abstractmethod
    def load(self):
        """
        Abstract method for calling load on each IO class of the specific derived DataHandler and returning the data
        in a tuple.
        """

    @abstractmethod
    def save(self, data):
        """
        Abstract method for calling save() on the IO class used for saving data in the specific derived DatSupplier.
        """


class SCCMDataHandler(IDataHandler):
    """
    Implementation of a DataHandler used to supply and write the data needed and generated by the SideChainGenerator
    Generator.
    """

    def __init__(self, **kwargs):

        self.sidechain_io = project_io.get_sidechain_io()
        self.id_iterator = iterators.IDIterator(project_io.get_id_io())

    def load(self):

        return self.sidechain_io.load()

    def save(self, data):

        self.sidechain_io.save(data)
        self.id_iterator.save()


class MGDataHandler(IDataHandler):
    """
    Implementation of a DataHandler used to supply and write the data needed and generated by the MonomerGenerator
    Generator.
    """

    def __init__(self, **kwargs):

        self.sidechain_loader = project_io.get_sidechain_io()
        self.monomer_saver = project_io.get_monomer_io()
        self.index_iterator = iterators.IndexIterator(project_io.get_index_io())

    def load(self):

        return self.sidechain_loader.load()

    def save(self, data):

        self.monomer_saver.save(data)
        self.index_iterator.save()


class TestPGDataHandler(IDataHandler):
    """
    Implementation of a DataHandler used to supply and write the data needed and generated by the PeptideGenerator
    Generator.
    """

    def __init__(self, **kwargs):

        self.monomer_loader = project_io.get_monomer_io()
        self.peptide_saver = project_io.get_peptide_io(**kwargs)
        self.peptide_length = kwargs['peptide_length']

    def load(self):
        return self.monomer_loader.load(), self.peptide_length

    def save(self, data):

        self.peptide_saver.save(data)


class PublicationPGDataHandler(IDataHandler):
    """
    Implementation of a DataHandler used to supply and write the data needed and generated by the PeptideGenerator
    Generator.
    """

    def __init__(self, **kwargs):

        self.peptide_saver = project_io.get_peptide_io(**kwargs)
        self.plan_loader = project_io.PeptidePlannerIO(kwargs['peptide_length'])

    def load(self):
        return self.plan_loader.load()

    def save(self, data):

        self.peptide_saver.save(data)


class TPGDataHandler(IDataHandler):

    def __init__(self, **kwargs):

        self.peptide_loader = project_io.get_peptide_io(**kwargs)
        self.template_peptide_saver = project_io.get_template_peptide_io(**kwargs)

    def load(self):

        return self.peptide_loader.load()

    def save(self, data):

        self.template_peptide_saver.save(data)


class MCGDataHandler(IDataHandler):

    def __init__(self, **kwargs):

        self.template_peptide_loader = project_io.get_template_peptide_io(**kwargs)
        self.reaction_loader = project_io.get_reaction_io()
        self.macrocycle_saver = project_io.get_macrocycle_io(**kwargs)

        try:
            self.start = kwargs['start']
            self.end = kwargs['end']
        except KeyError:
            self.start = -1
            self.end = 1000000000

    def load(self):

        MacrocycleGeneratorData = namedtuple('MacrocycleGeneratorData', 'template_peptides reactions')
        return MacrocycleGeneratorData(self.load_template_peptides(), self.reaction_loader.load())

    def save(self, data):

        self.macrocycle_saver.save(data)

    def load_template_peptides(self):

        for i, template_peptide in enumerate(self.template_peptide_loader.load()):
            if i < self.start:
                continue
            elif i >= self.end:
                break
            else:
                yield template_peptide


class UMRGDataHandler(IDataHandler):

    def __init__(self, **kwargs):

        self.templates = utils.get_templates()
        self.reactions = utils.get_unimolecular_reactions()
        self.reaction_saver = project_io.get_reaction_io()

    def load(self):

        return self.templates, self.reactions

    def save(self, data):

        self.reaction_saver.save(data)


class BMRGDataHandler(IDataHandler):

    def __init__(self, **kwargs):

        self.reactions = utils.get_bimolecular_reactions()
        self.sidechain_loader = project_io.get_sidechain_io()
        self.monomer_loader = project_io.get_monomer_io()
        self.reaction_saver = project_io.get_reaction_io()

    def load(self):

        reacting_mols = list(filter(lambda x: x['connection'] == 'methyl', self.sidechain_loader.load()))
        reacting_mols.extend(list(filter(lambda x: x['required'] and x['imported'], self.monomer_loader.load())))
        return reacting_mols, self.reactions

    def save(self, data):

        self.reaction_saver.save(data)
